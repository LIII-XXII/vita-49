//
// Copyright 2010 Free Software Foundation, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

//
// <protocol-msg> is the top-level PDU.
// It describes the messages exchanged on the wire.
//

//
// Everything is built on top of the ASN.1 type Expr, defined in
// vrt-ctrl-asn1-types.asn1.  Expr represents a choice of null, bool,
// integer, string, complex-int, ieee-float, complex-float types, or
// sequences of Exprs.  This representation is easily mapped into
// Python, Erlang, and C.
//
// All ASN.1 objects are encoded using the Distinguished Encoding Rules (DER)


// ------------------------------------------------------------------------
// For clarity in describing the protocol, the following productions
// represent instances of the underlying ASN.1 types.
// ------------------------------------------------------------------------

<null>    ::= NULL;			// ASN.1 NULL
	      			     	// Syntax: #null

<bool>    ::= BOOLEAN ;              	// ASN.1 BOOLEAN
	      	      		     	// Syntax: #t #f

<integer> ::= INTEGER ;		     	// ASN.1 INTEGER
	      	      		     	// Syntax: [0-9]+

<string>  ::= OCTET STRING ;         	// ASN.1 OCTET STRING
	      	    	   	     	// Syntax:  "blah, blah, blah"

<ieee-float> ::= IEEE-Float ;		// ASN.1 IEEE-Float

<complex-float> ::= Complex-float ; 	// ASN.1 Complex-float

<complex-int> ::= Complex-int;	    	// ASN.1 Complex-int


<basic-type> ::= <null>
               | <bool>
	       | <integer>
               | <string>
	       | <float>
	       | <complex-float>
	       | <complex-int>
	       ;


<expr> ::= <basic-type>			// ASN.1 Expr
         | <sequence>
	 ;


<sequence> ::= { <expr>* }		// Sequence of Expr
					// Syntax: { <expr>* }
					// (zero or more <expr>'s)

// ------------------------------------------------------------------------
// All messages on the wire are derived from <protocol-msg>.
// This is the top-level syntax.


<protocol-msg> ::= { <CALL> <invocation-id> <opcode-and-args> }	    // host -> radio
                 | { <REPLY> <invocation-id> <expr> }	      	    // radio -> host
                 | { <ERROR> <invocation-id> <error-info> }	    // radio -> host
                 | { <REJECT> <error-info> } 		  	    // radio -> host
                 | { <NOTE> <note-kind> <note-arg> }		    // radio -> host
		 ;

// Allows host to match responses to <CALL>s
<invocation-id> ::= <integer> ;


// There are only 3 operations defined.
// Everything is done in terms of these 3 operations.
//
// (This is more-or-less isomorphic to the Representational State Transfer (REST)
// architecture used in the modern web, where there is a virtually unbounded
// number of resources (device attributes) and a very small number of operations. 
// See FIXME.)
//
// <GET> Retrieves the value associated with a hierarchical <path> (aka key or property name).
// <PUT> Asks the device to associate <expr> as the value of <path>.
// <GET-META> Retrieves all metadata associated with <path>.  E.g., valid ranges of values.
//
// With these three operations any device attribute may be queried or set.
// <path> conventions are described in FIXME vrt-ctrl-path-conventions.txt
//
// See below for details. FIXME

<opcode-and-args> ::= { <GET>  <path> }
                    | { <GET-META> <path> }
                    | { <PUT> <path> <expr> }
		    ;

<error-info> ::= { <error-code> <error-arg> } ;
<error-code> ::= <integer> ;
<error-arg> ::= <expr> ;


<path> ::= '/'
         | <pathx>
	 ;

<pathx> := <path-component>
         | <path-component> <pathx>

<path-component> ::= '/' <path-term>

<path-term> ::= <alpha-path-term>
	      | <numeric-path-term>
	      ;

<alpha-path-term>   ::= '[a-z][a-z-]*' ;	// regular expression
<numeric-path-term> ::= '-?0x[0-9a-f]+'  ;	// regular expression

<note-kind> ::= <integer> ;		 	// see constants below
<note-arg>  ::= <expr> ;

// ----------------------------------------------------------------
// Constants

// protocol-msg constants

<CALL>      ::= 0 ;
<REPLY>	    ::= 1 ;
<ERROR>	    ::= 2 ;
<REJECT>    ::= 3 ;
<NOTICE>    ::= 4 ;

// opcode-and-args constants

<GET>       ::= 0 ;
<GET-META>  ::= 1 ;
<PUT>       ::= 2 ;

// note kind constants

<DEBUG-OUTPUT>   ::= 0 ;  // <note-arg> is <string> to be output or logged
<TX-UNDERRUN>    ::= 1 ;  // Transmitter ran out of samples in middle of burst; <note-arg> is <null>
<RX-OVERRUN>     ::= 2 ;  // Receiver ran out of buffer space in middle of burst; <note-arg> is <null>
<INTERNAL-ERROR> ::= 3 ;  // Device detected an internal problem; <note-arg> provides addl info

<VENDOR-NOTE>	 ::= 1024 ; // [1024 to 2047] are reserved for vendor use
